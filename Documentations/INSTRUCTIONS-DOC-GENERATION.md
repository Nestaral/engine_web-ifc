# Instructions for Generating AppVision Integration Documentation

## Context
You are tasked with generating technical documentation for an AppVision™ V4 integration driver. The documentation must be generated by analyzing C# WPF source code and filling an HTML template.

**Author:** Mathis Centauri  
**Template:** `appvision-doc-template.html`

---

## Step 1: Analyze the Source Code

### 1.0 Check for Video/Player Support — MANDATORY STEP
**CRITICAL:** Search the solution/project for any project or class containing "Player" in the name (e.g., `VideoPlayer`, `StreamPlayer`, `CameraPlayer`, `[Name]Player`, etc.)

- **If "Player" project/class is found:** 
  - KEEP the video/camera section in the documentation (marked with `<!-- VIDEO SECTION -->`)
  - Fill in the Camera variable properties
  - Document the stream URL format (RTSP, HTTP, MJPEG)
  - Include the player executable name (`[IntegrationName]Player.exe`)
  - **Analyze the Player class to detect implemented features (see 1.0.1)**
  
- **If NO "Player" project/class found:** 
  - REMOVE all content between `<!-- VIDEO SECTION -->` and `<!-- END VIDEO SECTION -->` comments
  - Remove RTSP port (554) from port matrix if present

**DO NOT SKIP THIS STEP. The video section must be either fully completed or fully removed.**

### 1.0.1 Detect Player Capabilities from Interfaces
Analyze the Player class declaration to identify implemented interfaces:

```csharp
public partial class Player[Name] : PlayerBaseControl, IPlayerLive, IPlayerPlayback, IPlayerPtz, IPlayerExport
```

| Interface | Feature | Document if present |
|-----------|---------|---------------------|
| `IPlayerLive` | Live video streaming | Yes - document live stream capability |
| `IPlayerPlayback` | Recording playback | Yes - document playback/timeline capability |
| `IPlayerPtz` | PTZ camera control | Yes - document PTZ section with commands |
| `IPlayerExport` | Video export | Yes - document export capability |
| `IPlayerAudio` | Audio support | Yes - document audio in/out capability |

### 1.0.2 Detect PTZ Capabilities from Properties
Search for `Can*` properties in the Player class to determine specific PTZ features:

```csharp
public override bool CanPresets => true;   // PTZ presets supported
public override bool CanPatterns => false; // PTZ patterns NOT supported
public override bool CanFocus => true;     // Focus control supported
```

| Property | If `true` | If `false` |
|----------|-----------|------------|
| `CanPresets` | Document preset commands (GoTo, Save, Add, Remove) | Omit preset section |
| `CanPatterns` | Document pattern commands (Start, Stop, Record) | Omit pattern section |
| `CanFocus` | Document focus commands (Focus, AutoFocus) | Omit focus section |
| `CanIris` | Document iris commands | Omit iris section |
| `CanZoom` | Document zoom commands | Omit zoom section (rare to be false) |

### 1.0.3 Detect Connection Parameters
Look for connection-related fields and parsing in the `Connect` method:

```csharp
private ushort _port = 30001;           // Default port
private string _userId;                  // Authentication
private string _password;
Helper.GetParameter("Channel", param)    // Additional parameters
```

Document these in the Device variable Address format.

### 1.1 Identify the Integration Name
- Look for the main driver class name (usually `AppDriver[Name].cs` or similar)
- Extract the integration/protocol name from namespace, class names, or constants
- This will replace all `[Integration Name]` placeholders

### 1.2 Extract Protocol Information
- Find the protocol configuration class or constants
- Identify:
  - Protocol name
  - Default ports used (HTTP, HTTPS, custom ports)
  - Communication protocol (TCP, UDP, REST API, WebSocket, etc.)
  - Authentication type (Digest, Basic, OAuth, API Key, etc.)

### 1.3 Map the Variable Tree Structure
Analyze the code to identify the hierarchical variable structure:

```
{System}                    → Root node (protocol level)
├── {Device}                → Device/equipment node
│   ├── Status variables    → Enumeration/Logical for states
│   ├── Command variables   → Variables with Command=true
│   └── Sub-devices         → Child nodes (relays, zones, etc.)
```

Look for:
- **Node variables**: Classes/structures representing equipment hierarchy
- **Status variables**: Properties that read device state (enums, booleans)
- **Command variables**: Methods/properties that send commands to devices
- **Sub-device patterns**: Repeated structures (Relay1-4, Zone1-n, etc.)

### 1.4 Extract Variable Properties
For each variable type found, document:

| Property | Where to find it |
|----------|------------------|
| Name | Property name, constant, or attribute |
| Type | `Node`, `Enumeration`, `Logical`, `Text`, `Numeric`, `Audio`, `Camera` |
| States | Enum values, constants, or switch cases |
| Command | Look for `[Command]` attributes or write-only properties |
| Address format | Connection string patterns in code |
| Other parameters | Configuration constants, default values |

### 1.5 Video Player Section (Conditional) — IF PLAYER EXISTS
**Only if a project/class containing "Player" exists, you MUST complete the Video Player section:**

1. **Fill the section header:**
   - Replace `[IntegrationName]` in `appPlayer[IntegrationName].dll`

2. **Keep or remove capability cards based on implemented interfaces and methods:**

   | Interface/Method | Card to keep | Description to use |
   |------------------|--------------|-------------------|
   | `IPlayerLive` | Live Streaming | Check `GetStreams()` for High/Low support |
   | `IPlayerPlayback` | Playback | Check `CanBackward`, `CanGoByStep` for details |
   | `IPlayerPtz` | PTZ Control | Check `CanPresets`, `CanPatterns`, `CanFocus` for details |
   | `IPlayerExport` | Export | Video export with progress tracking |
   | `SaveSnapshot()` method | Snapshot | Capture still images capability |

3. **Customize card descriptions based on actual capabilities:**
   - If `CanBackward => true`: mention "backward playback support"
   - If `CanPresets => true`: mention "preset management"
   - If `CanPatterns => false`: remove "patterns" from PTZ description
   - If `CanFocus => true`: mention "focus control"

4. **Camera Variable Configuration:**
   - The player is a DLL, not an EXE: `appPlayer[IntegrationName].dll`
   - Note in callout: "must be copied to each AppVision client `$Bin` directory"

**If NO "Player" project/class found:**
- Remove the entire `<!-- VIDEO PLAYER SECTION -->` block
- Remove the Video nav section from sidebar

### 1.5 Identify Features & Capabilities
Search for:
- API endpoints called (REST paths, methods)
- Event subscriptions (WebSocket, polling, callbacks)
- Supported commands (methods that send data to device)
- Status monitoring (methods that read from device)
- Special features (audio, video, alarms, etc.)

---

## Step 2: Extract Specific Code Patterns

### 2.1 Look for Enumerations
```csharp
public enum DeviceStatus { Normal, Fault, Alarm, Offline }
public enum CommState { Unknown, Connected, Disconnected, Fault }
```
→ These become variable States: `0:Normal`, `1:Fault`, `2:Alarm`, `3:Offline`

### 2.2 Look for Command Methods
```csharp
public void SendCommand(CommandType cmd) { ... }
public async Task ExecuteAction(string action) { ... }
```
→ These indicate Command variables

### 2.3 Look for Configuration/Parameters
```csharp
public int PollingIntervalMs { get; set; } = 2000;
public string AuthType { get; set; } = "Digest";
public bool AcceptUntrustedCertificates { get; set; } = true;
```
→ These become "Other parameters" in the documentation

### 2.4 Look for Address/Connection Patterns
```csharp
var url = $"https://{username}:{password}@{ipAddress}:{port}/api/v1";
```
→ This defines the Address format for device variables

### 2.5 Look for Sub-device Patterns
```csharp
public class Relay { public int Id; public bool Status; public void Activate(); }
public List<Relay> Relays { get; } // or Relay1, Relay2, Relay3, Relay4
```
→ These become `{Device}.RelayX` with `.Status` and `.Cmd` children

---

## Step 3: Fill the HTML Template

### 3.1 Replace All Placeholders

| Placeholder | Replace with |
|-------------|--------------|
| `[Integration Name]` | Extracted integration name |
| `[YYYY-MM-DD]` | Current date |
| `[X.X.X]` | Driver version (from AssemblyInfo or constant) |
| `[X]` (Rev) | Revision number (start with 1) |
| `[ProtocolName]` | Protocol identifier |
| `[Feature 1-5]` | List of capabilities found |
| `[State1-3]` | Enum states for Status variables |
| `[Command1-3]` | Available commands |

### 3.2 DO NOT MODIFY — Fixed Values
**NEVER change these values in the template:**
- AppVision version: **4.9** (keep as is, do not change to 4.0 or any other version)

### 3.3 Remove Screenshot Placeholders
**IMPORTANT:** Delete ALL `<div class="screenshot">` elements from the final documentation.

Do NOT leave:
```html
<div class="screenshot">
    [Screenshot: Protocol configuration interface]
</div>
```

These placeholder rectangles look unprofessional. Remove them entirely — screenshots can be added manually later if needed.

### 3.2 Generate the Variable Tree
Create the visual tree structure based on analyzed hierarchy:

```
{ProtocolName}                    Variable representing the system
├── {Device 1}                    Variable representing equipment
│   ├── Status                    Device state
│   ├── Comm                      Communication state
│   ├── [SpecificVar1]            Integration-specific variable
│   ├── [SpecificVar2]            Integration-specific variable
│   └── [SubDevice]X              Sub-device (X = 1 to n)
│       ├── Status                Sub-device state
│       └── Cmd                   Sub-device command
└── {Device n}                    Additional devices
```

### 3.3 Generate Property Tables
For each variable type, create a property table:

```html
<div class="table-wrapper property-table">
    <table>
        <thead>
            <tr><th>Property</th><th>Value</th></tr>
        </thead>
        <tbody>
            <tr><td>Name</td><td>[VariableName]</td></tr>
            <tr><td>Description</td><td>Free text</td></tr>
            <tr><td>Type</td><td>[Node|Enumeration|Logical|Text]</td></tr>
            <tr><td>States</td><td>0:[State0]<br>1:[State1]<br>...</td></tr>
        </tbody>
    </table>
</div>
```

### 3.4 Generate Port Matrix
Based on identified network communications:

| Service | Port | Protocol | Direction | Configurable |
|---------|------|----------|-----------|--------------|
| HTTP | 80 | TCP | In/Out | Yes |
| HTTPS | 443 | TCP | In/Out | Yes |
| [Custom] | [Port] | [TCP/UDP] | [Direction] | [Yes/No] |

### 3.5 Update Sidebar Navigation
Add navigation links for each variable section:
- One entry per major variable type
- Sub-links for sub-devices if applicable

---

## Step 4: Documentation Quality Checklist

Before finalizing, verify:

- [ ] **Video section check (CRITICAL):** 
  - If "Player" project exists → Camera section is COMPLETE with: variable table, stream URL format, player parameters
  - If NO "Player" project → ALL `<!-- VIDEO SECTION -->` blocks are REMOVED from HTML
- [ ] **Screenshot placeholders:** Remove ALL `<div class="screenshot">` blocks from the final documentation. Do NOT leave placeholder rectangles like "[Screenshot: ...]" — if no actual image is available, delete the entire div.
- [ ] All `[placeholder]` values have been replaced
- [ ] Variable tree matches the actual code structure
- [ ] All enum states are documented with correct indices
- [ ] Command variables have `Command: Ticked` in their tables
- [ ] Address format examples are accurate
- [ ] Port matrix includes all network communications
- [ ] Features list is complete and accurate
- [ ] No references to other companies/brands (only integration name)
- [ ] Author is set to "Mathis Centauri"
- [ ] Date is current

---

## Step 5: Output

Generate the final HTML file:
1. Copy the template
2. Replace all placeholders with extracted values
3. Add/remove variable sections as needed based on actual code structure
4. Save as `Supervision_[IntegrationName]-en.html`

---

## Example Variable Mapping

### From C# Code:
```csharp
public enum AlarmStatus { Normal = 0, Tamper = 1, Motion = 2, Fault = 3 }

public class ZoneManager {
    public AlarmStatus Status { get; }
    public bool Armed { get; set; }
    public void Arm() { ... }
    public void Disarm() { ... }
}
```

### To Documentation:

**Variable:** `{System}{Device}.Status`
| Property | Value |
|----------|-------|
| Name | Status |
| Type | Enumeration |
| States | 0:Normal<br>1:Tamper<br>2:Motion<br>3:Fault |

**Variable:** `{System}{Device}.ArmCmd`
| Property | Value |
|----------|-------|
| Name | ArmCmd |
| Type | Enumeration |
| Command | Ticked |
| States | 1:Arm<br>2:Disarm |

---

## Notes

- If the code structure doesn't match the template exactly, adapt the template
- Add new variable sections as needed for integration-specific features
- Remove template sections that don't apply to the integration
- Keep the visual style consistent with the template
- Screenshots placeholders can be left as `[Screenshot: description]` for manual addition later
